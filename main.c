#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "liym/liym.h"
#include "liyquant/liyquant.h"
#include "liyquant/liy3q.h"
#include "liyquant/liy2q.h"

int main(int argc, char* argv[]) {
	if (argc > 2) {
		printf("Too many args\n");
		return -1;
	}

	if (argc < 2) {
		printf("Not enough args\n");
		return -1;
	}

	FILE *infile;
	struct liymParseResults parse = openLiymFromFile(0, argv[1], infile);
	// ^Struct containing pointers to arrays of data      ^Parse specified model

	if (parse.filetype == 0) {
		printf("Parse failed or model has no data\n");
		return -1;
	} else {
		printf("Got filetype %d back from liym parser\n", parse.filetype);
	}

	char *friendlyname = malloc(strlen(argv[1]) * sizeof(char));
	for(int i = 0; 1; i++) {
		friendlyname[i] = argv[1][i];
		if(friendlyname[i] == '\0') {
			break;
		}
		if(friendlyname[i] == '.') {
			friendlyname[i] = '\0';
			break;
		}
	}

	char quantname[99];
	strcpy(quantname, friendlyname);
	strcat(quantname, "_liym3q.h");
	infile = fopen(quantname, "w"); //open as w and close to empty the file
	fclose(infile);

	infile = fopen(quantname, "a+");

	fprintf(infile, "//Autogenerated triple quantized liym file with draw function\n");

	char idxsname[99] = "int ";
	strcat(idxsname, friendlyname);
	strcat(idxsname, "tricount = ");
	fprintf(infile, idxsname);
	fprintf(infile, "%d;\n", parse.tricount);

	if(parse.filetype & 0b00000001) { //vertex position
		float sizek = ((float)parse.tricount * 9.0f * (float)sizeof(float)) / 1024.0f;
		printf("Requant %f kbyte vertpos array\n", sizek);

		struct liy3qResults recomp = liy3q_QuantTripleFloatArr(parse.vertpos, parse.tricount * 3);
		
		long recompsize = recomp.vertcount * 2;
		recompsize += recomp.uniquecount * 3 * 4;

		printf("Recompressed size is %f KiB\n", (float)recompsize / 1024.0f);

		char floatsname[99] = "f32 ";
		strcat(floatsname, friendlyname);
		strcat(floatsname, "vertpos[] ATTRIBUTE_ALIGN(32) = {");
		fprintf(infile, floatsname);
		
		for(int i = 0; i < recomp.uniquecount * 3; i++) {
			fprintf(infile, "%f, ", recomp.uniqueverts[i]);
		}
		fseeko(infile, -2, SEEK_END);
		int trimpos = ftello(infile);
		ftruncate(fileno(infile), trimpos);
		fprintf(infile, "};\n");

		char idxsname[99] = "uint16_t ";
		strcat(idxsname, friendlyname);
		strcat(idxsname, "vertposidx[] = {");
		fprintf(infile, idxsname);

		for(int i = 0; i < recomp.vertcount; i++) {
			fprintf(infile, "%d, ", recomp.vertidx[i]);
		}
		fseeko(infile, -2, SEEK_END);
		trimpos = ftello(infile);
		ftruncate(fileno(infile), trimpos);
		fprintf(infile, "};\n");

		freeliy3qResults(&recomp);
	}

	if(parse.filetype & 0b00000100) { //vertex normal
		float sizek = ((float)parse.tricount * 9.0f * (float)sizeof(float)) / 1024.0f;
		printf("Requant %f kbyte vertnor array\n", sizek);

		struct liy3qResults recomp = liy3q_QuantTripleFloatArr(parse.vertnor, parse.tricount * 3);
		
		long recompsize = recomp.vertcount * 2;
		recompsize += recomp.uniquecount * 3 * 4;

		printf("Recompressed size is %f KiB\n", (float)recompsize / 1024.0f);

		char floatsname[99] = "f32 ";
		strcat(floatsname, friendlyname);
		strcat(floatsname, "vertnor[] ATTRIBUTE_ALIGN(32) = {");
		fprintf(infile, floatsname);
		
		for(int i = 0; i < recomp.uniquecount * 3; i++) {
			fprintf(infile, "%f, ", recomp.uniqueverts[i]);
		}
		fseeko(infile, -2, SEEK_END);
		int trimpos = ftello(infile);
		ftruncate(fileno(infile), trimpos);
		fprintf(infile, "};\n");

		char idxsname[99] = "uint16_t ";
		strcat(idxsname, friendlyname);
		strcat(idxsname, "vertnoridx[] = {");
		fprintf(infile, idxsname);

		for(int i = 0; i < recomp.vertcount; i++) {
			fprintf(infile, "%d, ", recomp.vertidx[i]);
		}
		fseeko(infile, -2, SEEK_END);
		trimpos = ftello(infile);
		ftruncate(fileno(infile), trimpos);
		fprintf(infile, "};\n");

		freeliy3qResults(&recomp);
	}

	if(parse.filetype & 0b00001000) { //texture coordinate
		float sizek = ((float)parse.tricount * 6.0f * (float)sizeof(float)) / 1024.0f;
		printf("Requant %f kbyte texcord array\n", sizek);

		struct liy2qResults recomp = liy2q_QuantTripleFloatArr(parse.texcord, parse.tricount * 3);
		
		long recompsize = recomp.vertcount * 2;
		recompsize += recomp.uniquecount * 3 * 4;

		printf("Recompressed size is %f KiB\n", (float)recompsize / 1024.0f);

		char floatsname[99] = "f32 ";
		strcat(floatsname, friendlyname);
		strcat(floatsname, "texcord[] ATTRIBUTE_ALIGN(32) = {");
		fprintf(infile, floatsname);
		
		for(int i = 0; i < recomp.uniquecount * 2; i++) {
			fprintf(infile, "%f, ", recomp.uniqueverts[i]);
		}
		fseeko(infile, -2, SEEK_END);
		int trimpos = ftello(infile);
		ftruncate(fileno(infile), trimpos);
		fprintf(infile, "};\n");

		char idxsname[99] = "uint16_t ";
		strcat(idxsname, friendlyname);
		strcat(idxsname, "texcordidx[] = {");
		fprintf(infile, idxsname);

		for(int i = 0; i < recomp.vertcount; i++) {
			fprintf(infile, "%d, ", recomp.vertidx[i]);
		}
		fseeko(infile, -2, SEEK_END);
		trimpos = ftello(infile);
		ftruncate(fileno(infile), trimpos);
		fprintf(infile, "};\n");

		freeliy2qResults(&recomp);
	}

	if(parse.filetype & 0b00100000) {
		printf("This file has vertex colors so im just gonna copy them over as is\n");
		float sizek = ((float)parse.tricount * 3.0f * 1.0f) / 1024.0f; //8bpc
		printf("doing jack shit to %f kbyte vertcol array\n", sizek);

		char idxsname[99] = "uint8_t ";
		strcat(idxsname, friendlyname);
		strcat(idxsname, "vertcol[] = {");
		fprintf(infile, idxsname);

		for(int i = 0; i < parse.tricount * 9; i++) { //Actually clamp's them liek a boss
			int clampyclamp = (parse.vertcol[i] > 255) ? 255 : parse.vertcol[i];
			fprintf(infile, "%d, ", clampyclamp);
		}
		fseeko(infile, -2, SEEK_END);
		int trimpos = ftello(infile);
		ftruncate(fileno(infile), trimpos);
		fprintf(infile, "};\n");
	}

	if(parse.filetype & 0b01000000) {
		printf("This file has matrix indecies so im just gonna copy them over as is\n");
		float sizek = ((float)parse.tricount * 1.0f) / 1024.0f;
		printf("doing jack shit to %f kbyte mtxidx array\n", sizek);

		char idxsname[99] = "uint8_t ";
		strcat(idxsname, friendlyname);
		strcat(idxsname, "mtxidx[] = {");
		fprintf(infile, idxsname);

		for(int i = 0; i < parse.tricount * 3; i++) {
			fprintf(infile, "%d, ", parse.mtxidx[i]);
		}
		fseeko(infile, -2, SEEK_END);
		int trimpos = ftello(infile);
		ftruncate(fileno(infile), trimpos);
		fprintf(infile, "};\n");
	}
	
	printf("Autogenerating draw function\n");

	char decl[99] = "\nvoid ag_draw_";
	strcat(decl, friendlyname);
	strcat(decl, "(int vtxfmt) {\n");
	fprintf(infile, decl);
	
	if(parse.filetype & 0b00000001) {
		fprintf(infile, "	GX_SetArray(GX_VA_POS, &%svertpos[0], 12);\n", friendlyname);
	}
	if(parse.filetype & 0b00000100) {
		fprintf(infile, "	GX_SetArray(GX_VA_NRM, &%svertnor[0], 12);\n", friendlyname);
	}
	if(parse.filetype & 0b00001000) {
		fprintf(infile, "	GX_SetArray(GX_VA_TEX0, &%stexcord[0], 8);\n", friendlyname); //brash assumption
	}
	
	fprintf(infile, "	drawArrConfig(");
	if(parse.filetype & 0b00000001) { fprintf(infile, "LV_VPIDX16 | "); }
	if(parse.filetype & 0b00000100) { fprintf(infile, "LV_VNIDX16 | "); }
	if(parse.filetype & 0b00001000) { fprintf(infile, "LV_TCIDX16 | "); }
	if(parse.filetype & 0b01000000) { fprintf(infile, "LV_MX | "); }
	if(parse.filetype & 0b00100000) { fprintf(infile, "LV_VC | "); }
	fseeko(infile, -3, SEEK_END);
	ftruncate(fileno(infile), ftello(infile));
	fprintf(infile, ", %stricount, vtxfmt,\n", friendlyname);//lol
	if(parse.filetype & 0b00000001) {
		fprintf(infile, "		NULL, NULL, %svertposidx,\n", friendlyname);
	} else { 
		fprintf(infile, "		NULL, NULL, NULL,\n");
	}
	if(parse.filetype & 0b00000100) {
		fprintf(infile, "		NULL, NULL, %svertnoridx,\n", friendlyname);
	} else {
		fprintf(infile, "		NULL, NULL, NULL,\n");
	}
	if(parse.filetype & 0b00001000) {
		fprintf(infile, "		NULL, NULL, %stexcordidx,\n", friendlyname);
	} else {
		fprintf(infile, "		NULL, NULL, NULL,\n");
	}
	if(parse.filetype & 0b01000000) {
		fprintf(infile, "		%smtxidx,\n", friendlyname);
	} else {
		fprintf(infile, "		NULL,\n");
	}
	if(parse.filetype & 0b00100000) {
		fprintf(infile, "		%svertcol);\n", friendlyname);
	} else {
		fprintf(infile, "		NULL);\n");
	}
	
	fprintf(infile, "}\n");

	//Autogenerated apply vtx config

	char decl2[99] = "\nvoid ag_config_";
	strcat(decl2, friendlyname);
	strcat(decl2, "(int vtxfmt) {\n");
	fprintf(infile, decl2);

	fprintf(infile, "	liy_VtxDescConfig(");
	if(parse.filetype & 0b00000001) { fprintf(infile, "LV_VPIDX16 | "); }
	if(parse.filetype & 0b00000100) { fprintf(infile, "LV_VNIDX16 | "); }
	if(parse.filetype & 0b00001000) { fprintf(infile, "LV_TCIDX16 | "); }
	if(parse.filetype & 0b01000000) { fprintf(infile, "LV_MX | "); }
	if(parse.filetype & 0b00100000) { fprintf(infile, "LV_VC | "); }
	fseeko(infile, -3, SEEK_END);
	ftruncate(fileno(infile), ftello(infile));
	fprintf(infile, ", vtxfmt);\n}");
	
	fclose(infile);

	freeLiym(parse);
	printf("See ya\n");
	return 0;

}

